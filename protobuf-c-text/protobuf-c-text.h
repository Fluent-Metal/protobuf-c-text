/** \mainpage 
 *
 * Google protobufs are an efficient way to serialise and deserialise
 * data to send across the wire or to store on disk.  The Google compiler
 * and related libraries provide implementations for C++, Java and Python.
 * A very simple message definition language is used to generate parsers
 * and generators for this binary format.
 *
 * The Protobuf compiler and library for C provide access to this
 * technology from within C code.
 *
 * Besides the efficient binary protobuf format there is also a text mode
 * format which is accessible to code generated by the Google protobuf
 * compiler.  While the text format has limitations - namely that it lacks
 * some of the back/forwards-compatibility features of the binary format -
 * it can be a useful debugging tool and a strict but human readable config
 * file format.
 *
 * The C protobuf implementation is very minimal and lacks this feature.
 * This library supplements \c libprotobuf-c and provides functions to
 * generate and consume text format protobuf.  They will work fine with
 * any \c ProtobufCMessage subtype generated by the \c protoc-c
 * compiler.
 *
 * \sa
 *     - Google Protobufs: https://code.google.com/p/protobuf/
 *     - Protobuf docs:
 *       https://developers.google.com/protocol-buffers/docs/overview
 *     - Notes on protobuf compatibility:
 *       https://developers.google.com/protocol-buffers/docs/proto#updating
 *     - Protobuf for C: https://github.com/protobuf-c/protobuf-c
 *     - Protobuf for C docs:
 *       https://github.com/protobuf-c/protobuf-c/wiki
 *
 * \file
 * Library header file.
 * This is the header file for the text format protobuf routines.
 * It contains declarations of all functions and data types exported by
 * the library.
 *
 * \author Kevin Lyda <kevin@ie.suberic.net>
 * \date   March 2014
 *
 */

#ifndef PROTOBUF_C_TEXT_H
#define PROTOBUF_C_TEXT_H

#include <google/protobuf-c/protobuf-c.h>

/** \defgroup api Public API for text format protobufs
 *
 * These functions supplement the generated code from \c protoc-c to
 * allow you to import and export \c ProtobufCMessage structures
 * from/to the protobuf text mode serialisation.
 *
 * These will work with any code generated from \c protoc-c.
 * @{
 */

/** Structure for reporting API errors.
 *
 * Provides feedback on the success of an API call.  Generally if an
 * API call fails it will return NULL.  More detail on why it failed can
 * be found in the parameter with this type.
 */
typedef struct _TextFormatResult {
  int *error;       /**< Error code. 0 for success, >0 for failure. */
  char *error_txt;  /**< String with error message. */
  int complete;     /**< Reports whether the message is complete
                         (if supported):
                         - -1: Required field check wasn't performed - this
                               happens if your libprotobuf-c is too old.
                         - 0: The message was incomplete.
                         - >0: Message has all required fields set. */
} TextFormatResult;

/** Convert a \c ProtobufCMessage to a string.
 *
 * Given a \c ProtobufCMessage serialise it as a text format protobuf.
 *
 * \param[in] m The \c ProtobufCMessage to be serialised.
 * \param[in] allocator This is the same \c ProtobufCAllocator type used
 *                      by the \c libprotobuf-c library.  You can set it
 *                      to NULL to accept \c protobuf_c_default_allocator -
 *                      the default allocator.
 * \return The string with the text format serialised \c ProtobufCMessage.
 *         On failure it will return \c NULL.  On success, the resulting value
 *         be freed by you with the \c allocator you provided.  If you didn't
 *         provide an allocator technically you should do:
 *         \code
 * protobuf_c_default_allocator.free(
 *     protobuf_c_default_allocator.allocator_data, retval);
 *         \endcode
 *         Though technically \c free(retval); is probably sufficient.
 */
extern char *text_format_to_string(ProtobufCMessage *m,
    ProtobufCAllocator *allocator);

/** Import a text format protobuf from a string into a \c ProtobufCMessage.
 *
 * Given a string containing a text format protobuf, parse it and return
 * the corresponding \c ProtobufCMessage struct. On failure, \c NULL is
 * returned and \c result is updated with why.
 *
 * \param[in] descriptor The descriptor from the generated code.
 * \param[in] msg The string containing the text format protobuf.
 * \param[out] result This structure contains information on any error
 *                    that halted processing.
 * \param[in] allocator The \c ProtobufCAllocator struct.
 * \return The resulting \c ProtobufCMessage . It returns NULL on error.
 *         Check result->complete to make sure the message is valid.
 */
extern ProtobufCMessage *text_format_from_string(
    const ProtobufCMessageDescriptor *descriptor,
    char *msg,
    TextFormatResult *result,
    ProtobufCAllocator *allocator);

/** Import a text format protobuf from a \c FILE into a \c ProtobufCMessage.
 *
 * Given a \c FILE containing a text format protobuf, parse it and return
 * the corresponding \c ProtobufCMessage struct. On failure, \c NULL is
 * returned and \c result is updated with why.
 *
 * \param[in] descriptor The descriptor from the generated code.
 * \param[in] msg_file The \c FILE containing the text format protobuf.
 * \param[out] result This structure contains information on any error
 *                    that halted processing.
 * \param[in] allocator The \c ProtobufCAllocator struct.
 * \return The resulting \c ProtobufCMessage . It returns NULL on error.
 *         Check result->complete to make sure the message is valid.
 */
extern ProtobufCMessage *text_format_from_file(
    const ProtobufCMessageDescriptor *descriptor,
    FILE *msg_file,
    TextFormatResult *result,
    ProtobufCAllocator *allocator);

/** @} */   /* End of API group. */

#endif /* PROTOBUF_C_TEXT_H */
